<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Phone</title>

<style>
  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: system-ui, sans-serif;
    background: #000;
    color: #fff;
  }

  .container {
    max-width: 420px;
    margin: auto;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  h2 {
    margin: 0;
    font-size: 1.2rem;
    opacity: 0.8;
  }

  input, button {
    width: 100%;
    font-size: 1rem;
    padding: 12px;
    border-radius: 8px;
    border: none;
  }

  input {
    background: #111;
    color: white;
  }

  button {
    background: #1e1e1e;
    color: white;
    cursor: pointer;
  }

  button:active {
    background: #333;
  }

  hr {
    border: none;
    height: 1px;
    background: #222;
  }

  canvas {
    width: 100%;
    aspect-ratio: 1 / 1;
    background: white;
    border-radius: 8px;
    touch-action: none;
  }

  .row {
    display: flex;
    gap: 8px;
  }

  .row button {
    flex: 1;
  }

  input[type="file"] {
    display: none;
  }
</style>
</head>

<body>
<div class="container">

  <!-- TEXTE -->
  <h2>Texte</h2>
  <input id="textInput" placeholder="√âcris un message">

  <hr>

  <!-- PHOTOS -->
  <h2>Photo</h2>

  <button onclick="fileInput.click()">üìÅ Choisir une photo</button>
  <button onclick="cameraInput.click()">üì∑ Prendre une photo</button>

  <p id="photoStatus" style="opacity:0.7;font-size:0.9rem;">
    Aucune photo s√©lectionn√©e
  </p>

  <input id="fileInput" type="file" accept="image/*">
  <input id="cameraInput" type="file" accept="image/*" capture="environment">
  
  <hr>

  <!-- URL / Youtube -->

  <h2>Lien (image / GIF / YouTube)</h2>

  <input
    id="urlInput"
    placeholder="Colle un lien (image, GIF, YouTube)"
  />

  <p id="urlStatus" style="opacity:0.7;font-size:0.9rem;">
    Aucun lien
  </p>

  <hr>

  <!-- DESSIN -->
  <h2>Dessin</h2>
  <canvas id="canvas" width="300" height="300"></canvas>

  <div class="row">
    <button id="clearCanvas">Effacer</button>
  </div>

  <hr>

  <button id="sendAll" style="font-size:1.1rem;">
    üöÄ Envoyer
  </button>

  <p id="sendStatus" style="opacity:0.7;font-size:0.9rem;">
    Rien √† envoyer
  </p>

</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const socket = io();

// Elements
const textInput = document.getElementById('textInput');
const fileInput = document.getElementById('fileInput');
const cameraInput = document.getElementById('cameraInput');
const photoStatus = document.getElementById('photoStatus');
const urlInput = document.getElementById('urlInput');
const urlStatus = document.getElementById('urlStatus');
const sendAll = document.getElementById('sendAll');
const sendStatus = document.getElementById('sendStatus');

/* -------- IMAGE (file / camera) -------- */
let selectedImageFile = null;
let compressedImageData = null;

function onImageSelected(input) {
  const file = input.files[0];
  if (!file) return;

  selectedImageFile = file;
  photoStatus.textContent = `Photo pr√™te : ${file.name}`;

  compressImage(file);
}

function compressImage(file) {
  const img = new Image();
  const reader = new FileReader();

  reader.onload = e => {
    img.onload = () => {
      const MAX_SIZE = 800; // px
      let { width, height } = img;

      if (width > height && width > MAX_SIZE) {
        height *= MAX_SIZE / width;
        width = MAX_SIZE;
      } else if (height > MAX_SIZE) {
        width *= MAX_SIZE / height;
        height = MAX_SIZE;
      }

      const tmp = document.createElement('canvas');
      tmp.width = width;
      tmp.height = height;

      const ctx2 = tmp.getContext('2d');
      ctx2.drawImage(img, 0, 0, width, height);

      compressedImageData = tmp.toDataURL('image/jpeg', 0.7);
      photoStatus.textContent = `Photo pr√™te (${Math.round(compressedImageData.length / 1024)} KB)`;
    };

    img.src = e.target.result;
  };

  reader.readAsDataURL(file);
}

fileInput.onchange = () => onImageSelected(fileInput);
cameraInput.onchange = () => onImageSelected(cameraInput);

/* ---------- URL / YouTube parsing --------- */
function parseUrl(url) {
  const ytId = extractYoutubeId(url);
  if (ytId) {
    return {
      type: 'youtube',
      content: ytId,
      vertical: url.includes('/shorts/')
    };
  }

  if (url.match(/\.(png|jpe?g|gif|webp|svg|tiff)(\?.*)?$/i)) {
    return { type: 'image', content: url };
  }

  return null;
}

function extractYoutubeId(url) {
  try {
    const u = new URL(url);

    if (u.hostname.includes('youtu.be')) return u.pathname.slice(1);
    if (u.searchParams.get('v')) return u.searchParams.get('v');
    if (u.pathname.includes('/embed/')) return u.pathname.split('/embed/')[1];
    if (u.pathname.includes('/shorts/')) return u.pathname.split('/shorts/')[1];
    return null;
  } catch {
    return null;
  }
}

/* -------- DESSIN (canvas) -------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

ctx.lineWidth = 4;
ctx.lineCap = 'round';
ctx.strokeStyle = 'black';

let canvasHasDrawing = false;

function clearCanvasDrawing() {
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  canvasHasDrawing = false;
}

clearCanvasDrawing();

let drawing = false;

function pos(e) {
  const rect = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : e;
  return {
    x: (t.clientX - rect.left) * canvas.width / rect.width,
    y: (t.clientY - rect.top) * canvas.height / rect.height
  };
}

canvas.onmousedown = e => {
  drawing = true;
  const p = pos(e);
  ctx.beginPath();
  ctx.moveTo(p.x, p.y);
  canvasHasDrawing = true;
};

canvas.onmousemove = e => {
  if (!drawing) return;
  const p = pos(e);
  ctx.lineTo(p.x, p.y);
  ctx.stroke();
  canvasHasDrawing = true;
};

canvas.onmouseup = () => drawing = false;
canvas.onmouseleave = () => drawing = false;

canvas.ontouchstart = e => {
  drawing = true;
  const p = pos(e);
  ctx.beginPath();
  ctx.moveTo(p.x, p.y);
  canvasHasDrawing = true;
};

canvas.ontouchmove = e => {
  e.preventDefault();
  if (!drawing) return;
  const p = pos(e);
  ctx.lineTo(p.x, p.y);
  ctx.stroke();
  canvasHasDrawing = true;
};

canvas.ontouchend = () => drawing = false;

document.getElementById('clearCanvas').onclick = clearCanvasDrawing;

/* -------- SINGLE SEND BUTTON (text OR media OR both) -------- */
// Allow Enter in text and url inputs to trigger sendAll
textInput.addEventListener('keydown', e => { if (e.key === 'Enter') sendAll.click(); });
urlInput.addEventListener('keydown', e => { if (e.key === 'Enter') sendAll.click(); });

sendAll.onclick = () => {
  sendStatus.style.opacity = 1;

  // collect text (may be empty)
  const text = textInput.value.trim();

  // determine first available media in this order: image file, url (image|youtube), canvas drawing
  let mediaType = null;
  let mediaContent = null;
  let mediaSource = null; // 'file' | 'url' | 'canvas'

  // 1) image file (compressed)
  if (compressedImageData) {
    mediaType = 'image';
    mediaContent = compressedImageData;
    mediaSource = 'file';
  }

  // 2) URL (could be image or youtube)
  if (!mediaType) {
    const url = urlInput.value.trim();
    if (url) {
      const result = parseUrl(url);
      if (result) {
        mediaType = result.type; // 'image' or 'youtube'
        mediaContent = result.content;
        mediaSource = 'url';
      }
    }
  }

  // 3) canvas drawing
  if (!mediaType && canvasHasDrawing) {
    mediaType = 'image';
    mediaContent = canvas.toDataURL('image/png');
    mediaSource = 'canvas';
  }

  // nothing to send?
  if (!text && !mediaType) {
    sendStatus.textContent = 'Rien √† envoyer';
    sendStatus.style.opacity = 0.8;
    return;
  }

  // Build single message: if media exists, keep msg.type = mediaType and include optional text above it.
  // If no media, fallback to text-only message type 'text'.
  let msg = null;
  if (mediaType) {
    msg = { type: mediaType, content: mediaContent };
    if (text) msg.text = text; // TV will render text above media
  } else {
    msg = { type: 'text', content: text };
  }

  socket.emit('message', msg);

  // clear/feedback for the inputs we used
  if (text) textInput.value = '';

  if (mediaSource === 'file') {
    photoStatus.textContent = 'Photo envoy√©e ‚úÖ';
    compressedImageData = null;
    selectedImageFile = null;
    fileInput.value = '';
    cameraInput.value = '';
  }

  if (mediaSource === 'canvas') {
    clearCanvasDrawing();
  }

  if (mediaSource === 'url') {
    urlInput.value = '';
    urlStatus.textContent = 'Lien envoy√© ‚úÖ';
  }

  sendStatus.textContent = 'Envoy√© ‚úÖ';
  sendStatus.style.opacity = 0.8;
  setTimeout(() => { sendStatus.textContent = 'Rien √† envoyer'; sendStatus.style.opacity = 0.7; }, 1500);
};
</script>
</body>
</html>
