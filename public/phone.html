<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Live Chat IRL</title>

<style>
  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: system-ui, sans-serif;
    background: #000;
    color: #fff;
  }

  .container {
    max-width: 420px;
    margin: auto;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  h2 {
    margin: 0;
    font-size: 1.2rem;
    opacity: 0.8;
  }

  input, button {
    width: 100%;
    font-size: 1rem;
    padding: 12px;
    border-radius: 8px;
    border: none;
  }

  input {
    background: #111;
    color: white;
  }

  button {
    background: #1e1e1e;
    color: white;
    cursor: pointer;
  }

  button:active {
    background: #333;
  }

  hr {
    border: none;
    height: 1px;
    background: #222;
  }

  canvas {
    width: 100%;
    aspect-ratio: 1 / 1;
    background: white;
    border-radius: 8px;
    touch-action: none;
  }

  /* drawing controls */
  .palette {
    display: flex;
    gap: 8px;
    margin-top: 8px;
  }

  .colorBtn {
    width: 36px;
    height: 36px;
    border-radius: 8px;
    border: 2px solid rgba(255,255,255,0.15);
    box-shadow: 0 1px 0 rgba(0,0,0,0.3) inset;
    cursor: pointer;
  }

  .colorBtn.active {
    outline: 3px solid rgba(255,255,255,0.15);
    transform: translateY(-2px);
  }

  .sizes {
    display: flex;
    gap: 8px;
    margin-top: 8px;
  }

  .sizeBtn {
    padding: 8px 10px;
    border-radius: 8px;
    background: #111;
    cursor: pointer;
  }

  .sizeBtn.active {
    background: #fff;
    color: #000;
    transform: translateY(-2px);
  }

  .row {
    display: flex;
    gap: 8px;
  }

  .row button {
    flex: 1;
  }

  input[type="file"] {
    display: none;
  }
</style>
</head>

<body>
<div class="container">

  <!-- TEXTE -->
  <h2>Texte</h2>
  <input id="textInput" placeholder="√âcris un message">

  <hr>

  <!-- PHOTOS -->
  <h2>Photo</h2>

  <button onclick="fileInput.click()">üìÅ Choisir une photo</button>
  <button onclick="cameraInput.click()">üì∑ Prendre une photo</button>

  <p id="photoStatus" style="opacity:0.7;font-size:0.9rem;">
    Aucune photo s√©lectionn√©e
  </p>

  <input id="fileInput" type="file" accept="image/*">
  <input id="cameraInput" type="file" accept="image/*" capture="environment">
  
  <hr>

  <!-- URL / Youtube -->

  <h2>Lien (image / GIF / YouTube)</h2>

  <input
    id="urlInput"
    placeholder="Colle un lien (image, GIF, YouTube)"
  />

  <p id="urlStatus" style="opacity:0.7;font-size:0.9rem;">
    Aucun lien
  </p>

  <hr>

  <!-- DESSIN -->
  <h2>Dessin</h2>
  <canvas id="canvas" width="300" height="300"></canvas>

  <!-- palette et tailles -->
  <div class="palette" id="palette">
    <button class="colorBtn" data-color="#000000" title="noir" style="background:#000000"></button>
    <button class="colorBtn" data-color="#ffffff" title="blanc" style="background:#ffffff"></button>
    <button class="colorBtn" data-color="#ff0000" title="rouge" style="background:#ff0000"></button>
    <button class="colorBtn" data-color="#ff8000" title="orange" style="background:#ff8000"></button>
    <button class="colorBtn" data-color="#ffff00" title="jaune" style="background:#ffff00"></button>
    <button class="colorBtn" data-color="#00ff00" title="vert" style="background:#00ff00"></button>
    <button class="colorBtn" data-color="#00ffff" title="cyan" style="background:#00ffff"></button>
    <button class="colorBtn" data-color="#0000ff" title="bleu" style="background:#0000ff"></button>
    <button class="colorBtn" data-color="#ff00ff" title="magenta" style="background:#ff00ff"></button>
  </div>

  <div class="sizes" id="sizes">
    <button class="sizeBtn" data-size="1">‚óè</button>
    <button class="sizeBtn active" data-size="6">‚óè‚óè</button>
    <button class="sizeBtn" data-size="24">‚óè‚óè‚óè</button>
  </div>

  <div class="row">
    <button id="clearCanvas">Effacer</button>
  </div>

  <hr>

  <button id="sendAll" style="font-size:1.1rem;">
    üöÄ Envoyer
  </button>

  <p id="sendStatus" style="opacity:0.7;font-size:0.9rem;">
    Rien √† envoyer
  </p>

</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const socket = io();

// Elements
const textInput = document.getElementById('textInput');
const fileInput = document.getElementById('fileInput');
const cameraInput = document.getElementById('cameraInput');
const photoStatus = document.getElementById('photoStatus');
const urlInput = document.getElementById('urlInput');
const urlStatus = document.getElementById('urlStatus');
const sendAll = document.getElementById('sendAll');
const sendStatus = document.getElementById('sendStatus');

/* -------- IMAGE (file / camera) -------- */
let selectedImageFile = null;
let compressedImageData = null;
let storedImagePath = null; // server-stored GIF path

function onImageSelected(input) {
  const file = input.files[0];
  if (!file) return;

  selectedImageFile = file;
  photoStatus.textContent = `Photo pr√™te : ${file.name}`;

  // Detect GIF
  const isGif = file.type === 'image/gif' || /\.gif$/i.test(file.name);
  if (isGif) {
    // Upload GIF to server (no compression)
    photoStatus.textContent = 'Upload GIF en cours...';
    const fd = new FormData();
    fd.append('file', file);
    fetch('/upload-gif', { method: 'POST', body: fd })
      .then(r => r.json())
      .then(j => {
        if (j && j.path) {
          storedImagePath = j.path;
          photoStatus.textContent = `GIF pr√™t (${Math.round(file.size / 1024)} KB)`;
        } else {
          photoStatus.textContent = 'Erreur upload GIF';
        }
      })
      .catch(err => {
        console.error('upload-gif error', err);
        photoStatus.textContent = 'Erreur upload GIF';
      });
  } else {
    // Non-GIF: compress client-side
    compressImage(file);
  }
}

function compressImage(file) {
  const img = new Image();
  const reader = new FileReader();

  reader.onload = e => {
    img.onload = () => {
      const MAX_SIZE = 800; // px
      let { width, height } = img;

      if (width > height && width > MAX_SIZE) {
        height *= MAX_SIZE / width;
        width = MAX_SIZE;
      } else if (height > MAX_SIZE) {
        width *= MAX_SIZE / height;
        height = MAX_SIZE;
      }

      const tmp = document.createElement('canvas');
      tmp.width = width;
      tmp.height = height;

      const ctx2 = tmp.getContext('2d');
      ctx2.drawImage(img, 0, 0, width, height);

      compressedImageData = tmp.toDataURL('image/jpeg', 0.7);
      photoStatus.textContent = `Photo pr√™te (${Math.round(compressedImageData.length / 1024)} KB)`;
    };

    img.src = e.target.result;
  };

  reader.readAsDataURL(file);
}

fileInput.onchange = () => onImageSelected(fileInput);
cameraInput.onchange = () => onImageSelected(cameraInput);

/* ---------- URL / YouTube parsing --------- */
function parseUrl(url) {
  // validate URL first
  try {
    new URL(url);
  } catch {
    return null;
  }

  const ytId = extractYoutubeId(url);
  if (ytId) {
    return {
      type: 'youtube',
      content: ytId,
      vertical: url.includes('/shorts/')
    };
  }

  // For any other valid URL, treat it as an image (no extension regex)
  return { type: 'image', content: url };
}

function extractYoutubeId(url) {
  try {
    const u = new URL(url);

    if (u.hostname.includes('youtu.be')) return u.pathname.slice(1);
    if (u.searchParams.get('v')) return u.searchParams.get('v');
    if (u.pathname.includes('/embed/')) return u.pathname.split('/embed/')[1];
    if (u.pathname.includes('/shorts/')) return u.pathname.split('/shorts/')[1];
    return null;
  } catch {
    return null;
  }
}

/* -------- DESSIN (canvas) -------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// drawing settings
let currentColor = '#000000';
let currentSize = 6; // default medium

ctx.lineWidth = currentSize;
ctx.lineCap = 'round';
ctx.lineJoin = "round";
ctx.strokeStyle = currentColor;

let canvasHasDrawing = false;
let startPos = null;
let hasMoved = false;

function clearCanvasDrawing() {
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  canvasHasDrawing = false;
}

clearCanvasDrawing();

let drawing = false;

function pos(e) {
  const rect = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : e;
  return {
    x: (t.clientX - rect.left) * canvas.width / rect.width,
    y: (t.clientY - rect.top) * canvas.height / rect.height
  };
}


canvas.onmousedown = e => {
  drawing = true;
  hasMoved = false;
  const p = pos(e);
  startPos = p;
  ctx.beginPath();
  ctx.moveTo(p.x, p.y);
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = currentSize;
  canvasHasDrawing = true;
};

canvas.onmousemove = e => {
  if (!drawing) return;
  hasMoved = true;
  const p = pos(e);
  ctx.lineTo(p.x, p.y);
  ctx.stroke();
  canvasHasDrawing = true;
};

canvas.onmouseup = e => {
  if (!hasMoved && startPos) {
    // draw a single point
    ctx.beginPath();
    ctx.fillStyle = currentColor;
    const r = Math.max(1, Math.floor(currentSize / 2));
    ctx.arc(startPos.x, startPos.y, r, 0, Math.PI * 2);
    ctx.fill();
  }
  drawing = false;
};

canvas.onmouseleave = () => { drawing = false; };

canvas.ontouchstart = e => {
  drawing = true;
  hasMoved = false;
  const p = pos(e);
  startPos = p;
  ctx.beginPath();
  ctx.moveTo(p.x, p.y);
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = currentSize;
  canvasHasDrawing = true;
};

canvas.ontouchmove = e => {
  e.preventDefault();
  if (!drawing) return;
  hasMoved = true;
  const p = pos(e);
  ctx.lineTo(p.x, p.y);
  ctx.stroke();
  canvasHasDrawing = true;
};

canvas.ontouchend = e => {
  if (!hasMoved && startPos) {
    ctx.beginPath();
    ctx.fillStyle = currentColor;
    const r = Math.max(1, Math.floor(currentSize / 2));
    ctx.arc(startPos.x, startPos.y, r, 0, Math.PI * 2);
    ctx.fill();
  }
  drawing = false;
};

document.getElementById('clearCanvas').onclick = clearCanvasDrawing;

// palette & size wiring
function setActiveColor(color) {
  currentColor = color;
  ctx.strokeStyle = currentColor;
  document.querySelectorAll('.colorBtn').forEach(b => b.classList.toggle('active', b.getAttribute('data-color') === color));
}

function setActiveSize(size) {
  currentSize = Number(size);
  ctx.lineWidth = currentSize;
  document.querySelectorAll('.sizeBtn').forEach(b => b.classList.toggle('active', Number(b.getAttribute('data-size')) === currentSize));
}

document.querySelectorAll('.colorBtn').forEach(b => {
  b.addEventListener('click', () => setActiveColor(b.getAttribute('data-color')));
});

document.querySelectorAll('.sizeBtn').forEach(b => {
  b.addEventListener('click', () => setActiveSize(b.getAttribute('data-size')));
});

// initialize active selections
setActiveColor(currentColor);
setActiveSize(currentSize);

/* -------- SINGLE SEND BUTTON (text OR media OR both) -------- */
// Allow Enter in text and url inputs to trigger sendAll
textInput.addEventListener('keydown', e => { if (e.key === 'Enter') sendAll.click(); });
urlInput.addEventListener('keydown', e => { if (e.key === 'Enter') sendAll.click(); });

sendAll.onclick = () => {
  sendStatus.style.opacity = 1;

  // collect text (may be empty)
  const text = textInput.value.trim();

  // determine first available media in this order: image file, url (image|youtube), canvas drawing
  let mediaType = null;
  let mediaContent = null;
  let mediaSource = null; // 'file' | 'url' | 'canvas'
  let mediaVertical = false; // for YouTube shorts

  // 1) image file (stored GIF or compressed image)
  if (storedImagePath) {
    mediaType = 'image';
    mediaContent = storedImagePath;
    mediaSource = 'file';
  } else if (compressedImageData) {
    mediaType = 'image';
    mediaContent = compressedImageData;
    mediaSource = 'file';
  }

  // 2) URL (could be image or youtube)
  if (!mediaType) {
    const url = urlInput.value.trim();
    if (url) {
      const result = parseUrl(url);
      if (result) {
        mediaType = result.type; // 'image' or 'youtube'
        mediaContent = result.content;
        mediaVertical = result.vertical || false;
        mediaSource = 'url';
      }
    }
  }

  // 3) canvas drawing
  if (!mediaType && canvasHasDrawing) {
    mediaType = 'image';
    mediaContent = canvas.toDataURL('image/png');
    mediaSource = 'canvas';
  }

  // nothing to send?
  if (!text && !mediaType) {
    sendStatus.textContent = 'Rien √† envoyer';
    sendStatus.style.opacity = 0.8;
    return;
  }

  // Build single message: if media exists, keep msg.type = mediaType and include optional text above it.
  // If no media, fallback to text-only message type 'text'.
  let msg = null;
  if (mediaType) {
    msg = { type: mediaType, content: mediaContent, vertical: mediaVertical };
    if (text) msg.text = text; // TV will render text above media
  } else {
    msg = { type: 'text', content: text };
  }

  socket.emit('message', msg);

  // clear/feedback for the inputs we used
  if (text) textInput.value = '';

  if (mediaSource === 'file') {
    photoStatus.textContent = 'Photo envoy√©e ‚úÖ';
    compressedImageData = null;
    storedImagePath = null;
    selectedImageFile = null;
    fileInput.value = '';
    cameraInput.value = '';
  }

  if (mediaSource === 'canvas') {
    clearCanvasDrawing();
  }

  if (mediaSource === 'url') {
    urlInput.value = '';
    urlStatus.textContent = 'Lien envoy√© ‚úÖ';
  }

  sendStatus.textContent = 'Envoy√© ‚úÖ';
  sendStatus.style.opacity = 0.8;
  setTimeout(() => { sendStatus.textContent = 'Rien √† envoyer'; sendStatus.style.opacity = 0.7; }, 1500);
};
</script>
</body>
</html>
